// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: device.sql

package sqlc

import (
	"context"
)

const getDeviceAlerts = `-- name: GetDeviceAlerts :many
SELECT id, device_id, reason, "desc", timestamp
FROM alerts
WHERE device_id = ?1
  -- time window
  AND (CAST(?2 AS INTEGER) IS NULL OR timestamp >= ?2)
  AND (CAST(?3 AS INTEGER) IS NULL OR timestamp <= ?3)
  -- composite cursor
  AND (
    CAST(?4 AS INTEGER) IS NULL
        OR (
        -- timestamp less than previous page last row
        timestamp < ?4
            OR (
            -- or timestamp equal to previous page last row
            timestamp = ?4
                -- but is less than last row id
                AND (CAST(?5 AS INTEGER) IS NULL OR id < ?5)
            )
        )
    )
ORDER BY timestamp DESC, id DESC
LIMIT ?6
`

type GetDeviceAlertsParams struct {
	DeviceID string
	StartTs  *int64
	EndTs    *int64
	LastTs   *int64
	LastID   *int64
	Limit    int64
}

func (q *Queries) GetDeviceAlerts(ctx context.Context, arg GetDeviceAlertsParams) ([]*Alert, error) {
	rows, err := q.db.QueryContext(ctx, getDeviceAlerts,
		arg.DeviceID,
		arg.StartTs,
		arg.EndTs,
		arg.LastTs,
		arg.LastID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Alert
	for rows.Next() {
		var i Alert
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.Reason,
			&i.Desc,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDeviceConfig = `-- name: GetDeviceConfig :one
SELECT temperature_threshold, battery_threshold
FROM configs
WHERE device_id = ?
`

type GetDeviceConfigRow struct {
	TemperatureThreshold float64
	BatteryThreshold     int64
}

func (q *Queries) GetDeviceConfig(ctx context.Context, deviceID string) (*GetDeviceConfigRow, error) {
	row := q.db.QueryRowContext(ctx, getDeviceConfig, deviceID)
	var i GetDeviceConfigRow
	err := row.Scan(&i.TemperatureThreshold, &i.BatteryThreshold)
	return &i, err
}

const getDeviceMetrics = `-- name: GetDeviceMetrics :many
SELECT id, device_id, temperature, battery, timestamp
FROM metrics
WHERE device_id = ?1
  -- time window
  AND (CAST(?2 AS INTEGER) IS NULL OR timestamp >= ?2)
  AND (CAST(?3 AS INTEGER) IS NULL OR timestamp <= ?3)
  -- composite cursor
  AND (
    CAST(?4 AS INTEGER) IS NULL
        OR (
        -- timestamp less than previous page last row
        timestamp < ?4
            OR (
            -- or timestamp equal to previous page last row
            timestamp = ?4
                -- but is less than last row id
                AND (CAST(?5 AS INTEGER) IS NULL OR id < ?5)
            )
        )
    )
ORDER BY timestamp DESC, id DESC
LIMIT ?6
`

type GetDeviceMetricsParams struct {
	DeviceID string
	StartTs  *int64
	EndTs    *int64
	LastTs   *int64
	LastID   *int64
	Limit    int64
}

func (q *Queries) GetDeviceMetrics(ctx context.Context, arg GetDeviceMetricsParams) ([]*Metric, error) {
	rows, err := q.db.QueryContext(ctx, getDeviceMetrics,
		arg.DeviceID,
		arg.StartTs,
		arg.EndTs,
		arg.LastTs,
		arg.LastID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.Temperature,
			&i.Battery,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveDeviceAlert = `-- name: SaveDeviceAlert :exec
INSERT INTO alerts (device_id, reason, desc, timestamp)
VALUES (?, ?, ?, ?)
`

type SaveDeviceAlertParams struct {
	DeviceID  string
	Reason    string
	Desc      string
	Timestamp int64
}

func (q *Queries) SaveDeviceAlert(ctx context.Context, arg SaveDeviceAlertParams) error {
	_, err := q.db.ExecContext(ctx, saveDeviceAlert,
		arg.DeviceID,
		arg.Reason,
		arg.Desc,
		arg.Timestamp,
	)
	return err
}

const saveDeviceMetric = `-- name: SaveDeviceMetric :exec
INSERT INTO metrics (device_id, temperature, battery, timestamp)
VALUES (?, ?, ?, ?)
`

type SaveDeviceMetricParams struct {
	DeviceID    string
	Temperature float64
	Battery     int64
	Timestamp   int64
}

func (q *Queries) SaveDeviceMetric(ctx context.Context, arg SaveDeviceMetricParams) error {
	_, err := q.db.ExecContext(ctx, saveDeviceMetric,
		arg.DeviceID,
		arg.Temperature,
		arg.Battery,
		arg.Timestamp,
	)
	return err
}

const upsertDeviceConfig = `-- name: UpsertDeviceConfig :exec
INSERT INTO configs (device_id, temperature_threshold, battery_threshold)
VALUES (?, ?, ?)
ON CONFLICT(device_id) DO UPDATE
    SET temperature_threshold=excluded.temperature_threshold,
        battery_threshold=excluded.battery_threshold
`

type UpsertDeviceConfigParams struct {
	DeviceID             string
	TemperatureThreshold float64
	BatteryThreshold     int64
}

func (q *Queries) UpsertDeviceConfig(ctx context.Context, arg UpsertDeviceConfigParams) error {
	_, err := q.db.ExecContext(ctx, upsertDeviceConfig, arg.DeviceID, arg.TemperatureThreshold, arg.BatteryThreshold)
	return err
}
